## Shortcut to get detection probability
calc.detfn <- function(d, detfn, pars, ss.link = NULL, orientation = 0){
    g <- get.detfn(detfn)
    if (identical(g, calc.ss)){
        out <- g(d, pars, ss.link, orientation)
    } else {
        out <- g(d, pars)
    }
    out
}

## Returns a detection function.
get.detfn <- function(detfn){
    if (!(detfn %in% c("hn", "hr", "th", "lth", "ss", "log.ss", "spherical.ss"))){
        stop("Argument 'detfn' must be \"hn\", \"hr\", \"th\", \"lth\", \"ss\", \"log.ss\", or \"spherical.ss\".")
    }
    switch(detfn, hn = calc.hn, hr = calc.hr, th = calc.th,
           lth = calc.lth, ss = calc.ss, log.ss = calc.ss, spherical.ss = calc.ss)
}

calc.hn <- function(d, pars){
    if (!identical(sort(names(pars)), c("g0", "sigma"))){
        stop("Argument 'pars' must have named components 'g0' and 'sigma'.")
    }
    g0 <- pars$g0
    sigma <- pars$sigma
    g0*exp(-(d^2/(2*sigma^2)))
}

calc.hr <- function(d, pars){
    if (!identical(sort(names(pars)), c("g0", "sigma", "z"))){
        stop("Argument 'pars' must have named components 'g0', 'sigma', and 'z'.")
    }
    g0 <- pars$g0
    sigma <- pars$sigma
    z <- pars$z
    g0*(1 - exp(-((d/sigma)^-z)))
}

calc.th <- function(d, pars){
    if (!identical(sort(names(pars)), c("scale", "shape"))){
        stop("Argument 'pars' must have named components 'scale' and 'shape'.")
    }
    scale <- pars$scale
    shape <- pars$shape
    0.5 - 0.5*erf(d/scale - shape)
}

calc.lth <- function(d, pars){
    if (!identical(sort(names(pars)), c("scale", "shape.1", "shape.2"))){
        stop("Argument 'pars' must have named components 'scale', 'shape.1', and 'shape.2'.")
    }
    scale <- pars$scale
    shape.1 <- pars$shape.1
    shape.2 <- pars$shape.2
    0.5 - 0.5*erf(shape.1 - exp(shape.2 - scale*d))
}

calc.ss <- function(d, pars, ss.link, orientation){
    if (!any(names(pars) == "b2.ss")){
        warning("Parameter b2.ss is missing. Setting to zero.")
        pars$b2.ss <- 0
    }
    if (!any(names(pars) == "sigma.b0.ss")){
        warning("Parameter sigma.b0.ss is missing. Setting to zero.")
        pars$sigma.b0.ss <- 0
    }
    if (!identical(sort(names(pars)), c("b0.ss", "b1.ss", "b2.ss", "cutoff", "sigma.b0.ss", "sigma.ss"))){
        stop("Argument 'pars' must have named components 'b0.ss', 'b1.ss', 'b2.ss', 'sigma.b0.ss', 'sigma.ss', and 'cutoff'.")
    }

    b0.ss <- pars$b0.ss
    b1.ss <- pars$b1.ss
    b2.ss <- pars$b2.ss
    sigma.b0.ss <- pars$sigma.b0.ss
    sigma.ss <- pars$sigma.ss
    cutoff <- pars$cutoff
    if (ss.link == "log"){
        mean <- exp(b0.ss - (b1.ss - b2.ss*(cos(orientation) - 1))*d)
    } else if (ss.link == "identity") {
        mean <- b0.ss - (b1.ss - b2.ss*(cos(orientation) - 1))*d
    } else if (ss.link == "spherical"){
        mean <- b0.ss - 10*log10(d^2) - (b1.ss - b2.ss*(cos(orientation) - 1))*(d - 1)
    } else {
        stop("Link function not recognised.")
    }
    out <- 1 - pnorm(cutoff, mean = mean, sd = sigma.ss)
    out
}

#' Plotting a detection function.
#'
#' Plots an estimated detection function from a model fit generated by
#' \link{fit.ascr}.
#'
#' @param xlim A vector with two elements, giving the x-axis
#' limits. If \code{NULL}, this is set to the buffer of the mask.
#' @param ylim A vector with two elements, giving the y-axis limits.
#' @param add Logical, if \code{TRUE}, the estimated detection
#' function is added to an existing plot.
#' @param ... Further arguments to be passed to \link{lines}.
#' @inheritParams locations
#' @inheritParams graphics::title
#'
#' @examples
#' ## Comparison of two detection functions fitted to the same data
#' show.detfn(example$fits$simple.hn, main = "Detection function comparison")
#' show.detfn(example$fits$simple.hr, add = TRUE, col = "blue")
#' legend("topright", legend = c("Half normal", "Hazard rate"), lty = 1, col = c("black", "blue"), bg = "white")
#'
#' @export
show.detfn <- function(fit, xlim = NULL, ylim = c(0, 1), main = NULL,
                       xlab = "Distance (m)", ylab = "Detection probability",
                       add = FALSE, ...){
    if (is.null(xlim)){
        buffer <- attr(get.mask(fit), "buffer")
        if (!is.null(buffer)){
            x.max <- buffer
        } else {
            dists <- distances(get.traps(fit, 1), get.mask(fit, 1))
            edge.point <- which(dists[1, ] == max(dists[1, ]))[1]
            x.max <- min(dists[, edge.point])
        }
        xlim <- c(0, x.max)
    }
    dists <- seq(xlim[1], xlim[2], length.out = 1000)
    probs <- detfn(fit, dists)
    if (!add){
        plot.new()
        old.par <- par(xaxs = "i")
        plot.window(xlim = xlim, ylim = ylim)
        axis(1)
        axis(2)
        box()
        abline(h = c(0, 1), col = "lightgrey")
        title(main = main, xlab = xlab, ylab = ylab)
        par(old.par)
    }
    lines(dists, probs, ...)
}

#' Calculating the detection function from a fitted model object.
#'
#' Calculates detection probabilities from a fitted model's estimated
#' detection function.
#'
#' @param d A vector of distances.
#' @inheritParams locations
#'
#' @return A vector of detection probabilities.
#'
#' @export
detfn <- function(fit, d){
    detfn <- fit$args$detfn
    pars <- get.par(fit, pars = fit$detpars, cutoff = fit$fit.types["ss"],
                    as.list = TRUE)
    if (any(names(pars) == "sigma.b0.ss")){
        if (pars$sigma.b0.ss != 0){
            warning("Detection probabilities only calculated for the average emitted cue strength.")
        }
    }
    if (any(names(pars) == "b2.ss")){
        if (pars$b2.ss != 0){
            warning("Detection probabilities only calculated for a detector directly in line with the direction of the cue.")
        }
    }
    calc.detfn(d, detfn = detfn, pars = pars, ss.link = fit$args$ss.opts$ss.link)
}
